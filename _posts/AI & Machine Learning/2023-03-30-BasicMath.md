---
layout: post
title: Basic Math Expressions in Machine Learning
subtitle: Written with ChatGPT
categories: markdown MachineLearning
tags: [Machine Learning,Math]
---

## 线性代数

- 向量和矩阵的基本概念
- 矩阵运算，如加、减、乘、转置和求逆
- 线性方程组的求解
- 特征值和特征向量的计算

## 概率论和统计学

- ### 基本概念

  - 概率：$P(A)$
  - 条件概率：$P(A\mid B)$
  - 期望：$E(X)$
  - 方差：$Var(X)$
  - 协方差：$Cov(X,Y)$
  - 相关系数：$Corr(X,Y)$

- ### 常见概率分布

  - 伯努利分布：$P(X=k)=p^k(1-p)^{1-k}$，$k\in{0,1}$，$p$为概率参数
  - 二项分布：$P(X=k)=\binom{n}{k}p^k(1-p)^{n-k}$，$k\in{0,1,\dots,n}$，$n$为试验次数，$p$为概率参数
  - 正态分布：$f(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$，$\mu$为均值，$\sigma^2$为方差
  - t分布：
    $$
    f(t)=\frac{\Gamma(\frac{\nu+1}{2})}{\sqrt{\nu\pi}\Gamma(\frac{\nu}{2})}(1+\frac{t^2}{\nu})^{-\frac{\nu+1}{2}}
    $$
    $\nu$为自由度
  - 卡方分布：
    $$
     f(x)=\frac{1}{2^{\frac{k}{2}}\Gamma(\frac{k}{2})}x^{\frac{k}{2}-1}e^{-\frac{x}{2}}
    $$
  ，$k$为自由度
  - F分布
  
    $$
    f(x)=\frac{\Gamma(\frac{v_1+v_2}{2})}{\Gamma(\frac{v_1}{2})\Gamma(\frac{v_2}{2})}(\frac{v_1}{v_2})^{\frac{v_1}{2}}x^{\frac{v_1}{2}-1}(1+\frac{v_1}{v_2}x)^{-\frac{v_1+v_2}{2}}
    $$
    $v_1,v_2$为自由度

- ### 估计和检验

  - 最大似然估计：$\hat{\theta}*{ML}=\arg\max*{\theta}L(\theta;X_1,X_2,\dots,X_n)$，$L$为似然函数，$X_1,X_2,\dots,X_n$为样本
  - 置信区间：$P(\theta_1<\theta<\theta_2)=1-\alpha$，$\alpha$为显著性水平，$\theta_1,\theta_2$为区间端点
  - 假设检验：$H_0:\theta=\theta_0$，$H_1:\theta\neq\theta_0$，$t=\frac{\hat{\theta}-\theta_0}{SE(\hat{\theta})}$，$SE$为标准误，$t$服从$t$分布
  - 方差分析：$F=\frac{MSTr}{MSE}$，$MSTr$为组间均方，$MSE$为组内均方，$F$服从$F$分布
  - 单因素方差分析：$y_{ij}=\mu_i+\epsilon_{ij}$，$i$表示第$i$组，$j$表示第$j$个样本，$\mu_i$表示第$i$组的均值，$\epsilon_{ij}$表示误差
  - 两个总体均值差的检验（独立样本）：$t=\frac{\bar{X_1}-\bar{X_2}}{S_p\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$，$S_p$为样本方差的加权平均，$t$服从$t$分布
  - 两个总体均值差的检验（配对样本）：$t=\frac{\bar{D}-\mu_D}{S_D/\sqrt{n}}$，$\bar{D}$为差值的平均数，$S_D$为差值的标准差，$\mu_D$为总体均值差，$t$服从$t$分布
  - 单个总体均值的检验：$t=\frac{\bar{X}-\mu_0}{S/\sqrt{n}}$，$\mu_0$为假设的总体均值，$S$为样本标准差，$t$服从$t$分布
  - 单个总体比例的检验：$z=\frac{\hat{p}-p_0}{\sqrt{\frac{p_0(1-p_0)}{n}}}$，$p_0$为假设的总体比例，$z$服从标准正态分布
  - 两个总体比例的检验：$z=\frac{\hat{p_1}-\hat{p_2}}{\sqrt{\hat{p}(1-\hat{p})(\frac{1}{n_1}+\frac{1}{n_2})}}$，$\hat{p}$为两个样本中成功的总比例，$z$服从标准正态分布

- 最大似然估计和贝叶斯估计

- 统计假设检验和置信区间

## 求导和优化

### 导数和偏导数的计算

#### 基本导数公式：

- $\frac{d}{dx}(c) = 0$，其中$c$为常数
- $\frac{d}{dx}(x^n) = nx^{n-1}$，其中$n$为实数
- $\frac{d}{dx}(e^x) = e^x$
- $\frac{d}{dx}(\ln x) = \frac{1}{x}$
- $\frac{d}{dx}(\sin x) = \cos x$，$\frac{d}{dx}(\cos x) = -\sin x$，$\frac{d}{dx}(\tan x) = \sec^2 x$

链式法则：$(f(g(x)))' = f'(g(x))g'(x)$

梯度：$\nabla f(x) = \frac{\partial f(x)}{\partial x} = \begin{bmatrix} \frac{\partial f(x)}{\partial x_1} \ \frac{\partial f(x)}{\partial x_2} \ \vdots \ \frac{\partial f(x)}{\partial x_n} \end{bmatrix}$，表示函数$f(x)$在$x$点处的梯度向量

梯度下降法：$x_{n+1} = x_n - \alpha \nabla f(x_n)$，其中$\alpha$为学习率，控制每次更新的步长大小

牛顿法：$x_{n+1} = x_n - \frac{f'(x_n)}{f''(x_n)}$，其中$f'(x_n)$为函数$f(x)$在$x_n$处的一阶导数，$f''(x_n)$为函数$f(x)$在$x_n$处的二阶导数

拟牛顿法：使用近似的方式计算梯度和海森矩阵，通过不断迭代来逼近最优解

### 梯度和海森矩阵的计算

#### 海森矩阵

海森矩阵是一个二阶偏导数组成的矩阵，用于描述一个多元函数的曲率和梯度的变化情况。假设有一个二元函数$f(x,y)$，则它的海森矩阵为
$$
H(f) = \begin{bmatrix}
\frac{\partial^2 f}{\partial x^2} & \frac{\partial^2 f}{\partial x \partial y} \\
\frac{\partial^2 f}{\partial y \partial x} & \frac{\partial^2 f}{\partial y^2}
\end{bmatrix}
$$
其中，$H_{i,j}=\frac{\partial^2 f}{\partial x_i \partial x_j}$，表示函数$f$在$x$处的曲率和梯度的变化情况。

在优化问题中，海森矩阵通常被用来近似描述目标函数的局部二次性质，例如在牛顿法和拟牛顿法中，海森矩阵被用来计算步长大小和更新方向。然而，由于海森矩阵的计算代价较高，通常会采用一些近似方法来计算。

在优化问题中，海森矩阵的计算通常会非常耗时，因为它涉及到计算目标函数的二阶偏导数。因此，为了提高计算效率，通常会采用一些近似方法来计算海森矩阵的近似值，常见的方法有以下几种：

1. 牛顿法：在牛顿法中，海森矩阵被直接计算并求逆，用来计算每次迭代的步长大小和方向。
2. BFGS算法：BFGS算法是一种拟牛顿法，它使用一个对海森矩阵的逆的估计来更新每一步的搜索方向。BFGS算法通常比牛顿法更具有鲁棒性，因为它能够在迭代过程中自适应地更新参数。
3. L-BFGS算法：L-BFGS算法是BFGS算法的一种改进，它使用一个有限的内存来存储一些历史信息，从而避免了需要存储整个海森矩阵的计算量和存储量，通常比BFGS算法更适用于大规模数据集和高维数据集。
4. 随机梯度算法：随机梯度算法通常被用于处理大规模数据集的优化问题，它通过使用一个小批量的样本来估计目标函数的梯度，从而避免了需要对整个数据集进行计算的问题，也避免了存储整个海森矩阵的问题。

这些近似方法都是为了减少计算量和存储量，并在迭代中逐步逼近最优解。

梯度下降和牛顿法的优化算法

梯度下降和牛顿法都是常用的优化算法。

梯度下降法的公式为：
$$
\theta_{t+1} = \theta_t - \alpha \nabla J(\theta_t)
$$
其中 $\theta_t$ 表示在第 $t$ 次迭代中的参数值，$\alpha$ 表示学习率，$J(\theta_t)$ 表示损失函数在参数 $\theta_t$ 处的值，$\nabla J(\theta_t)$ 表示损失函数在参数 $\theta_t$ 处的梯度。

牛顿法的公式为：
$$
\theta_{t+1} = \theta_t - H^{-1}(\theta_t) \nabla J(\theta_t)
$$
其中 $\theta_t$ 表示在第 $t$ 次迭代中的参数值，$H(\theta_t)$ 表示损失函数在参数 $\theta_t$ 处的海森矩阵，$H^{-1}(\theta_t)$ 表示海森矩阵的逆，$\nabla J(\theta_t)$ 表示损失函数在参数 $\theta_t$ 处的梯度。

正则化方法，如L1和L2正则化

正则化是机器学习中常用的一种方法，目的是防止模型过拟合。L1和L2正则化是两种常见的正则化方法。

L1正则化，也称为Lasso正则化，是通过在损失函数中加入L1范数来实现的。其公式如下：
$$
\min_{\theta}\, J(\theta) + \lambda \|\theta\|_1
$$
其中 $J(\theta)$ 表示模型的损失函数，$\theta$ 表示模型参数，$|\theta|_1$ 表示$\theta$的L1范数，$\lambda$ 是正则化强度超参数。L1正则化的效果是将一些模型参数的值变成0，从而实现特征选择。

L2正则化，也称为Ridge正则化，是通过在损失函数中加入L2范数来实现的。其公式如下：
$$
\min_{\theta}\, J(\theta) + \lambda \|\theta\|_2^2
$$
其中 $J(\theta)$ 表示模型的损失函数，$\theta$ 表示模型参数，$|\theta|_2$ 表示$\theta$的L2范数，$\lambda$ 是正则化强度超参数。L2正则化的效果是让模型参数的值变得较小，从而使得模型对训练数据的变化更加鲁棒。

需要注意的是，L1正则化的结果往往比L2正则化更稀疏，也就是说，它更容易使得模型参数的值为0。而L2正则化的效果更加平滑，会让模型的参数值接近于0。在实际应用中，通常需要对不同的问题选择不同的正则化方法。

## 线性回归

- 简单线性回归和多元线性回归
- 最小二乘法和梯度下降法的求解
- 模型评估和预测

## 逻辑回归

- 二分类和多分类问题
- 逻辑函数和sigmoid函数的定义
- 最大似然估计和梯度下降法的求解
- 模型评估和预测

## 支持向量机

支持向量机（Support Vector Machine, SVM）是一种二分类模型，它的基本思想是找到一个最优的超平面，能够将不同类别的数据分隔开来。SVM在许多实际问题中都表现出良好的分类性能。

SVM的核心是将高维空间中的数据点映射到低维空间中，并在低维空间中找到最优的超平面。SVM的目标是最大化超平面到各个类别的最近数据点的距离，也就是最大化边缘（margin），从而提高分类的准确性。

SVM的分类器可以分为线性SVM和非线性SVM。线性SVM在低维空间中寻找一个线性的超平面，可以通过简单的线性代数方法求解。而非线性SVM在低维空间中找到一个非线性的超平面，可以通过核函数将低维空间中的数据映射到高维空间中进行求解。

SVM在实际应用中需要选择适当的核函数和超参数，并使用交叉验证等方法对模型进行调优。SVM还有一些变种，如多类SVM和回归SVM，可以用于不同的问题和任务。

SVM的优点是具有良好的泛化性能和较高的准确性，能够处理高维数据和非线性数据，还可以使用核函数进行特征映射。缺点是对于大规模数据集的计算复杂度较高，而且需要选择适当的核函数和超参数。

### 最大间隔分离超平面的定义

最大间隔分离超平面是支持向量机（SVM）分类器的关键组成部分，其定义为：在训练数据中找到一个能够将不同类别的数据点分开的超平面，使得这个超平面到各类最近数据点的距离（即边缘）最大。

在二维空间中，最大间隔分离超平面是一条直线，将两类数据点分开。在高维空间中，最大间隔分离超平面是一个超平面，将不同类别的数据点分开。最大间隔分离超平面的定义保证了SVM分类器的泛化能力和鲁棒性。

在数学上，最大间隔分离超平面可以表示为：
$$
w^Tx + b = 0
$$
其中，$w$ 是超平面的法向量，$x$ 是数据点的特征向量，$b$ 是偏置项。根据这个超平面，我们可以将一个新的数据点分类为正类或负类，即根据其在超平面的哪一侧来决定其分类标签。

在找到最大间隔分离超平面之后，我们可以根据支持向量（即与超平面距离最近的数据点）的位置和数量，确定决策边界的位置，以及对新的数据点进行分类的策略。

### 对偶问题的求解和核技巧的应用

支持向量机（SVM）的原始问题（primal problem）是一个优化问题，可以通过拉格朗日对偶性将其转化为对偶问题（dual problem），并且对偶问题更容易求解。具体来说，SVM的对偶问题为：

$\min_{\alpha}\frac{1}{2}\sum_{i=1}^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j\langle x_i,x_j\rangle-\sum_{i=1}^{m}\alpha_i$

$subject\ to\ \sum_{i=1}^{m}\alpha_iy_i=0,0\leq\alpha_i\leq C,i=1,\dots,m$

其中，$\alpha$ 是拉格朗日乘子，$y_i\in{-1,1}$ 是训练数据的标签，$x_i$ 是训练数据的特征向量，$\langle x_i,x_j\rangle$ 是特征向量之间的内积，$C$ 是一个常数，表示正则化参数。

在求解SVM的对偶问题时，我们需要找到一组拉格朗日乘子 $\alpha$，使得满足约束条件的情况下，目标函数最小化。这个问题可以使用凸优化算法进行求解，例如序列最小优化算法（SMO）。

另外，核技巧（kernel trick）也是支持向量机的一个重要概念。核技巧的思想是将输入特征映射到高维特征空间中，以便于在高维空间中使用线性分类器进行分类。这个过程可以通过定义一个核函数来实现，核函数可以直接计算特征向量在高维空间中的内积，而无需显式地将特征向量映射到高维空间中。在SVM中，常用的核函数包括线性核函数、多项式核函数、高斯核函数等。通过使用核函数，SVM可以在高维空间中进行分类，从而提高分类器的性能。

### 软间隔和多类问题的处理

软间隔支持向量机允许一些样本点处于超平面错误的一侧，这个错误率可以通过调整正则化参数 $C$ 来控制。具体来说，当 $C$ 越大时，正则化惩罚越小，允许更多的错误分类；而当 $C$ 越小时，正则化惩罚越大，更加强调分类的准确性。软间隔支持向量机的优化问题可以表示为：

$\min_{w,b,\xi}\frac{1}{2}\Vert w\Vert^2+C\sum_{i=1}^{m}\xi_i$

$subject\ to\ y_i(w^Tx_i+b)\geq1-\xi_i,\xi_i\geq0,i=1,\dots,m$

其中 $\xi$ 是松弛变量，允许一些样本点处于超平面错误的一侧。对于每个样本点 $i$，$\xi_i$ 表示它与正确的超平面之间的距离。目标函数的第一项是正则化项，控制模型的复杂度；第二项是惩罚项，用于惩罚错误分类的样本。

对于多类问题，可以使用多种方法来扩展支持向量机。一种常见的方法是一对多（one-vs.-rest）方法，即将多类问题转化为多个二元分类问题。对于每个类别，我们训练一个二元支持向量机来区分该类别和其余的类别。在测试时，我们将测试样本输入到每个分类器中进行分类，最终将样本分配给得分最高的类别。

另一种方法是一对一（one-vs.-one）方法，即将多类问题转化为多个二元分类器之间的组合问题。对于 $k$ 个类别，我们训练 $k(k-1)/2$ 个分类器，每个分类器区分两个不同的类别。在测试时，我们将测试样本输入到每个分类器中进行分类，统计每个类别获得的得分，最终将样本分配给得分最高的类别。

以上是支持向量机常见的变体，这些变体使得支持向量机在实际应用中具有更广泛的适用性和可扩展性。

## 模型评估和预测

在机器学习中，模型的评估和预测是非常重要的步骤。在训练模型后，需要对其进行评估以确定其性能如何，并在新数据上进行预测。

### 模型评估

模型评估可以使用许多不同的指标，这些指标通常与问题的类型和目标有关。以下是一些常见的模型评估指标：

- 准确率（accuracy）：表示模型正确分类的样本数占总样本数的比例，是最常见的评估指标之一。
- 精确率（precision）：表示预测为正例的样本中，真正为正例的比例。
- 召回率（recall）：表示真正为正例的样本中，被正确预测为正例的比例。
- F1得分（F1-score）：是精确率和召回率的加权平均，用于综合考虑这两个指标。
- ROC曲线和AUC值：ROC曲线是根据不同的阈值绘制的真正例率（TPR）和假正例率（FPR）的曲线，AUC表示ROC曲线下面积。

### 预测

在模型训练之后，可以使用其进行预测。预测通常包括以下步骤：

- 数据预处理：将新的数据预处理为模型可接受的格式。
- 特征提取：从新的数据中提取特征，并将其转换为模型所期望的特征格式。
- 模型预测：使用已训练的模型进行预测，并生成相应的输出。
- 输出后处理：将模型生成的输出进行后处理，以生成最终结果。

对于不同类型的问题，预测的方式也会有所不同。例如，在分类问题中，预测通常是将新数据分类为已知的类别之一，而在回归问题中，预测通常是预测一个数值。